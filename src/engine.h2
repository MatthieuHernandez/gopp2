#include "goban.h2"
#include "move.h2"

Engine: type = {

    public goban: Goban = ();
    public moves: std::vector<Move> = ();
    public nextMovePlayer: Color;
    
    public blackPoint: i16 = 0;
    public whitePoint: i16 = 0;

   operator=:(out this) = {
        nextMovePlayer = Color::Black;
    }

    playMove:(inout this, in m: Move) = {
        moves.push_back(m);
        if !m.pass {
            col:= m.stone.col;
            row:= m.stone.row;
            goban.state[col][row] = m.stone;
            if goban.lockedPosition.color == m.stone.color {
                goban.unlockPosition();
                std::cout << "Stone unlockled." << std::endl;
            }
        }
        nextMovePlayer = otherColor(nextMovePlayer);
    }

    private countLiberties:(inout this, inout stone: Stone, inout count: i16, inout processedStones: State<bool>) = {
        processedStones[stone.col][stone.row] = true;
        nextStones:= goban.getAdjacentStone(stone, processedStones);
        for nextStones
        do (inout nextStone) {
            if !processedStones[nextStone.col][nextStone.row] {
                if nextStone.color == Color::None {
                    processedStones[nextStone.col][nextStone.row] = true;
                    count++;
                } else if nextStone.color == stone.color {
                    countLiberties(nextStone, count, processedStones);
                }
            }
        }
    }

    numberOfLiberties:(inout this, inout stone: Stone) -> i16 = {
        processedStones: State<bool> = ();
        count: i16 = 0;
        countLiberties(stone, count, processedStones);
        processedStones = processedStones;
        return count;
    }

    removeGroup:(inout this, inout stone: Stone, inout count: i16, inout processedStones: State<bool>) = {
        nextStones:= goban.getAdjacentStone(stone, processedStones);
        for nextStones
        do (inout nextStone) {
            std::cout << "stone.color " << stone.color as i32 << std::endl;
            std::cout << "nextStone.color " << nextStone.color as i32 << std::endl;
            if nextStone.color == stone.color {
                goban.removeStone(nextStone);
                processedStones[nextStone.col][nextStone.row] = true;
                std::cout << "nextStone removed" << std::endl;
                count++;
                removeGroup(nextStone, count, processedStones);
            }
        }
    }

    captureStones:(inout this, inout stone: Stone) -> i16 = {
        processedStones: State<bool> = ();
        count: i16 = 0;
        color:= otherColor(stone.color);
        nextStones:= goban.getAdjacentStone(stone, processedStones);
        for nextStones
        do (inout nextStone) {
            if nextStone.color == color {
                l:= numberOfLiberties(nextStone);
                if l == 1 {
                    std::cout << "Remove group." << std::endl;
                    removeGroup(nextStone, count, processedStones);
                    goban.removeStone(nextStone);
                    count++;
                    if count == 1 {
                        goban.lockPosition(nextStone, color);
                    }
                }
            }
        }
        if count > 1 {
            goban.unlockPosition();
        }
        return count;
    }

    isValidMove:(inout this, inout m: Move) -> bool = {
        if m.pass {
            return true;
        }
        col:= m.stone.col;
        row:= m.stone.row;
        if goban.state[col][row].color == Color::None &&
            (goban.lockedPosition.col != col || goban.lockedPosition.row != row) {
            numberOfcapturedStones:= captureStones(m.stone);
            if numberOfLiberties(m.stone) > 0 ||
                numberOfcapturedStones > 0 {
                return true;
            }
        }
        return false;
    }

    isFinish:(this) -> bool = {
        if moves.ssize() > 1 {
            if moves[moves.size() - 1].pass == true
            && moves[moves.size() - 2].pass == true {
                return true;
            }
        }
        return false;
    }

    countTerritory:(inout this, inout stone: Stone, inout count: i16, inout color: Color,
        inout processedStones1: State<bool>, inout processedStones2: State<bool>) = {
        if count == 0 {
            return;
        }
        processedStones2[stone.col][stone.row] = true;
        nextStones:= goban.getAdjacentStone(stone, processedStones2);
        for nextStones
        do (inout nextStone) {
            if nextStone.color == Color::None {
                if !processedStones2[nextStone.col][nextStone.row] {
                    processedStones1[nextStone.col][nextStone.row] = true;
                    count++;
                    countTerritory(nextStone, count, color, processedStones1, processedStones2);
                }
            }
            else if nextStone.color == Color::Black && color != Color::White {
                color = Color::Black;
            }
            else if nextStone.color == Color::White && color != Color::Black {
                color = Color::White;
            } else{
                count = 0;
                return;
            }
            processedStones2[nextStone.col][nextStone.row] = true;
        }
    }

    countScore:(inout this) = {
        processedStones1: State<bool> = ();
        blackPoint = 0;
        whitePoint = 7;
        (copy col: i8 = 0)
        while col < goban.state.ssize()
        next col++
        {
            (copy row: i8 = 0)
            while row < goban.state[col].ssize()
            next row++
            {
                if !processedStones1[col][row] {
                    processedStones1[col][row] = true;
                    if goban.state[col][row].color == Color::Black {
                        blackPoint++;
                    }
                    else if goban.state[col][row].color == Color::White {
                        whitePoint++;
                    }
                    else {
                        count: i16 = 1;
                        color:= Color::None;
                        processedStones2: State<bool> = ();
                        countTerritory(goban.state[col][row], count, color, processedStones1, processedStones2);
                        processedStones2 = processedStones2;
                        if color == Color::Black {
                            blackPoint+= count;
                        }
                        if color == Color::White {
                            whitePoint+= count;
                        }
                    }
                }
            }
        }
    }
}
