#include "goban.h2"
#include "move.h2"

Engine: type = {

    public goban: Goban = ();
    public moves: std::vector<Move> = ();
    public nextMovePlayer: Color;

   operator=:(out this) = {
        nextMovePlayer = Color::Black;
    }

    playMove:(inout this, in m: Move) = {
        moves.push_back(m);
        if !m.pass {
            col:= m.stone.col;
            row:= m.stone.row;
            goban.state[col][row] = m.stone;
            //std::cout << "The stone is " << m.stone.color as i32 << std::endl;
            //std::cout << "The stone is " <<  goban.state[col][row].color as i32 << std::endl;
            switchPlayer(nextMovePlayer);
        }
    }

    countLiberties:(inout this, inout stone: Stone, inout count: i16) = {
        goban.processStone(stone);
        nextStones:= goban.getAdjacentStone(stone);
        for nextStones
        do (inout nextStone) {
            if !goban.stonehasBeenProcessed(nextStone) {
                if nextStone.color == Color::None {
                    goban.processStone(nextStone);
                    count++;
                    std::cout << "COUNT" << std::endl;
                } else if nextStone.color == stone.color {
                    std::cout << "HERE" << std::endl;
                    countLiberties(nextStone, count);
                }
            }
        }
    }

    numberOfLiberties:(inout this, inout stone: Stone) -> i16 = {
        count: i16 = 0;
        countLiberties(stone, count);
        goban.clearProcessedStone();
        return count;
    }

    isValidMove:(inout this, inout m: Move) -> bool = {
        if m.pass {
            return true;
        }
        col:= m.stone.col;
        row:= m.stone.row;
        if goban.state[col][row].color == Color::None &&
            (numberOfLiberties(m.stone) > 0 || captureStone() == true ) {
            return true;
        }
        return false;
    }

    captureStone:() -> bool = {
        return false;
    }

    isFinish:(this) -> bool = {
        if moves.ssize() > 1 {
            if moves[moves.size() - 1].pass == true
            && moves[moves.size() - 2].pass == true {
                return true;
            }
        }
        return false;
    }
}
