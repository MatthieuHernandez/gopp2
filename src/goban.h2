#include "stone.h2"

template<class T>
using State = std::array<std::array<T, 19>, 19>;

Goban: type = {
    public state: State<Stone> = ();

    public lockedPosition: Stone = ();

    operator=:(out this) = {
        (copy col: i8 = 0)
        while col < state.ssize()
        next col++
        {
            (copy row: i8 = 0)
            while row < state[col].ssize()
            next row++
            {
                state[col][row] = Stone(Color::None, col, row);
            }
        }
    }

    getAdjacentStone:(in this, in s: Stone, in processedStones: State<bool>) -> std::vector<Stone>  = {
        // v√©rifier les bounds.
        adjacent_stones: std::vector<Stone> = ();
        if s.col > 0 {
            if !processedStones[s.col-1][s.row] {
                adjacent_stones.push_back(state[s.col-1][s.row]);
            }
        }
        if s.col < 18 {
            if !processedStones[s.col+1][s.row] {
                adjacent_stones.push_back(state[s.col+1][s.row]);
            }
        }
        if s.row > 0 {
            if !processedStones[s.col][s.row-1] {
                adjacent_stones.push_back(state[s.col][s.row-1]);
            }
        }
        if s.row < 18 {
            if !processedStones[s.col][s.row+1] {
                adjacent_stones.push_back(state[s.col][s.row+1]);
            }
        }
        //std::cout << adjacent_stones.ssize() << " adjacent_stones" << std::endl;
        return adjacent_stones;
    }

    removeStone:(inout this, s: Stone) = {
        state[s.col][s.row].color = Color::None;
    }

    lockPosition:(inout this, s: Stone, c: Color) = {
        lockedPosition = s;
        lockedPosition.color = c;
    }

    unlockPosition:(inout this) = {
        lockedPosition.color = Color::None;
        lockedPosition.row = -1;
        lockedPosition.col = -1;
    }
}