#include "windows.h"

#include "io.h2"
#include "game.h2"
#include "human.h2"
#include "random.h2"
#include "ai.h2"

isSaving: bool = false;

void signalHandler(int signal) {
    if (signal == SIGINT) {
        while(isSaving) {
            std::cout << "Cannot stop, saving in progress..." << std::endl;
        }
        std::exit(0);
    }
}

gameHumanVsHuman:() = {
    clear();
    setNextMessage("Start a new game.");
    player1:= shared.new<Human>(Color::Black);
    player2:= shared.new<Human>(Color::White);
    game:= Game(player1, player2);
    game.play<true>();
    waitInput();
}

gameHumanVsRandom:() = {
    clear();
    setNextMessage("Start a new game.");
    player1:= shared.new<Human>(Color::Black);
    player2:= shared.new<Random>(Color::White);
    game:= Game(player1, player2);
    game.play<true>();
    waitInput();
}

gameHumanVsAi:(modelPath: std::string) = {
    clear();
    if modelPath == "" {
        setNextMessage("No model selected." );
        return;
    }
    setNextMessage("Start a new game.");
    player1:= shared.new<Human>(Color::Black);
    player2:= shared.new<Ai>(Color::White, modelPath);
    game:= Game(player1, player2);
    game.play<true>();
    waitInput();
}

gameRandomVsRandom:() = {
    clear();
    setNextMessage("Start a new game.");
    player1:= shared.new<RandomSlow>(Color::Black, 500);
    player2:= shared.new<RandomSlow>(Color::White, 500);
    game:= Game(player1, player2);
    game.play<true>();
    waitInput();
}

gameAiVsAi:(modelPath: std::string) = {
    clear();
    if modelPath == "" {
        setNextMessage("No model selected." );
        return;
    }
    player1:= shared.new<Ai>(Color::Black, modelPath);
    player2:= shared.new<Ai>(Color::White, modelPath);
    game:= Game(player1, player2);
    i: i32 = 0;
    while true
    {
        game.play<false>();
        player1*.train();
        //player2*.train();
        if i % 20 == 0 {
            isSaving = true;
            player1*.save();
            isSaving = false;
        }
        i++;
    }
}

loadAi:() -> std::string = {
    clear();
    modelPath:= SelectSnnModel();
    clear();
    printSnnModel(modelPath);
    setNextMessage(modelPath + " selected." );
    return modelPath;
}

evaluateAi:(modelPath: std::string) = {
    clear();
    if modelPath == "" {
        setNextMessage("No model selected.");
        return;
    }
    numberOfGame: i16 = 100;
    numberOfGameWon: i16 = 0;
    player1:= shared.new<Ai>(Color::Black, modelPath);
    player2:= shared.new<Random>(Color::White);
    game:= Game(player1, player2);

    (copy i: i32 = 0)
    while i < numberOfGame
    next i++
    {
        game.play<false>();
        if player1*.hasWon {
            numberOfGameWon++;
        }
        if i == (numberOfGame / 2 - 1) {
            game.switchPlayerColor();
        }
    }
    setNextMessage("The AI evaluated won " + numberOfGameWon as std::string +
                   "/" + numberOfGame as std::string + " games againt random.");
}
// The AI evaluated won 45/100 games againt random.

cpp2_main:() -> int = {
    signal(SIGINT, signalHandler);
    SetConsoleOutputCP(CP_UTF8);
    exit: bool = false;
    modelPath: std::string = "";
    do {
        printMenu();
        selection: int = getInputMenu();
        if selection == 0 {
            clear("Bye.");
            exit = true;
        } else if selection == 1 {
            gameHumanVsHuman();
        } else if selection == 2 {
            gameHumanVsRandom();
        } else if selection == 3 {
            gameHumanVsAi(modelPath);
        } else if selection == 4 {
            gameRandomVsRandom();
        } else if selection == 5 {
            gameAiVsAi(modelPath);
        } else if selection == 6 {
            evaluateAi(modelPath);
        } else if selection == 7 {
            modelPath = loadAi();
        } else if selection == 9 {
            createAi();
            setNextMessage("AI created.");
        } else {
            setNextMessage("Invalid selection.");
        }
    } while !exit;
  return 0;
}


int main() {
    try { // CPP2 workaround: Try catch not yet supported.
        return cpp2_main();
    } catch (const std::exception& e) {
        std::cerr << "Caught exception: " << e.what() << std::endl;
    }
    return 0;
}