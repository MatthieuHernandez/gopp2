#include "player.h2"
#include <snn/neural_network/StraightforwardNeuralNetwork.hpp>

createAi:() = {
    layers: std::vector<snn::LayerModel> = (snn::Input(361),
                                            snn::FullyConnected(100),
                                            snn::FullyConnected(361));
    optimizer:= snn::StochasticGradientDescent(1e-8f, 0.0f);
    neuralNetwork:= snn::StraightforwardNeuralNetwork(layers, optimizer);
    neuralNetwork.saveAs("./snn_models/first_model_2.snn");
}

Ai: type = {
    this: Player;
    private neuralNetwork: snn::StraightforwardNeuralNetwork;
    private inputs: snn::vector2D<float>;
    private moves : std::vector<i16>;

    public operator=:(out this, c: Color) = {
        Player = (c);
        neuralNetwork = snn::StraightforwardNeuralNetwork::loadFrom("./snn_models/first_model.snn");
        inputs = ();
        moves = ();
        inputs.reserve(300);
        moves.reserve(300);
    }

    public operator=:(out this, that) = {
        Player = (that);
        neuralNetwork = that.neuralNetwork;
    }

    private getGobanState:(in this, in state: State<Stone>) -> std::vector<float> = {
        vec: std::vector<float> = ();
        vec.reserve(361);
        (copy col: i8 = 0)
        while col < state.ssize()
        next col++
        {
            (copy row: i8 = 0)
            while row < state[col].ssize()
            next row++
            {
                if state[col][row].color == color {
                    vec.push_back(1.0);
                }
                else if state[col][row].color == Color::None {
                    vec.push_back(0.0);
                }
                else {
                    vec.push_back(-1.0);
                }
            }
        }
        return vec;
    }

    private chooseBestMove:(in this, in nn_output: std::vector<float>) -> Move = {
        index: i16 = 0;
        max: float = 0;
        max_col: i8 = 0;
        max_row: i8 = 0;
        (copy col: i8 = 0)
        while col < 19
        next col++
        {
            (copy row: i8 = 0)
            while row < 19
            next row++
            {
                if max < nn_output[index] {
                    max = nn_output[index];
                    max_col = col;
                    max_row = row;
                }
                index++;
            }
        }
        m:= Move(color, max_col, max_row);
        return m;
    }

    public getMove:(override inout this, inout engine: Engine) -> Move = {
        input:= getGobanState(engine.goban.state);
        output:= neuralNetwork.computeOutput(input);
        m:= chooseBestMove(output);
        engine.closerValidMove(m);
        moveIndex:= m.stone.getIndex();
        if moveIndex >= 0 {
            inputs.push_back(input);
            moves.push_back(moveIndex);
        }
        return m;
    }

    public train:(inout this) = {
        expectedValue: float = -1.0;
        if hasWon { // CPP2 workaround: Conditional operator not yet supported.
            expectedValue = -1;
        }
        (copy i: i16 = 0)
        while i < inputs.ssize()
        next i++
        {
            expected_output:= inputs[i];
            (copy j: i16 = 0)
            while j < 361
            next j++
            {
                if inputs[i][j] != 0.0 {
                    expected_output[j] = -1;
                }
            }
            expected_output[moves[i]] = expectedValue;
            neuralNetwork.trainOnce(inputs[i], expected_output);
        }
    }
    
    public save:(inout this) = {
        neuralNetwork.saveAs("./snn_models/first_model.snn");
    }
}
